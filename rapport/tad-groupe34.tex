\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\AddThinSpaceBeforeFootnotes 
\FrenchFootnotes 
\usepackage[scaled=.90]{helvet}
\usepackage{mathptmx}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage[hidelinks]{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=blue,
filecolor=magenta,
urlcolor=cyan,
pdfpagemode=FullScreen,
}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Codingstyle}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind}
\usepackage[titles,subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
language=C, % Utilisation du langage C
commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
frame=single, % Entoure le code d'un joli cadre
rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
numbers=left, % Ajoute une numérotation des lignes à gauche
numbersep=5pt, % Distance entre les numérots de lignes et le code
numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
basicstyle=\tt\footnotesize,
tabsize=3, % Largeur des tabulations par défaut
keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
extendedchars=true,
captionpos=b, % sets the caption-position to bottom
texcl=true, % Commentaires sur une ligne interprétés en Latex
showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
inputencoding=utf8,
literate=
{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
{Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
{à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
{À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
{ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
{Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
{â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
{Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
{œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
{ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
{ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
{€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
{»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
% Complétez et décommentez les définitions de macros suivantes :
\newcommand{\intitule}{Complément de programmation \\ Projet 2: TAD \& Récursivité.}
\newcommand{\GrNbr}{34}
\newcommand{\PrenomUN}{Timothy}
\newcommand{\NomUN}{Smeers}
\newcommand{\PrenomDEUX}{Soline}
\newcommand{\NomDEUX}{Lèbre}
% Décommentez ceci si vous voulez une table des matières :
\renewcommand{\tablemat}{\tableofcontents}

%%%%%%%% ZONE PROTÉGÉE : MODIFIEZ UNE DES DIX PROCHAINES %%%%%%%%
%%%%%%%%            LIGNES POUR PERDRE 2 PTS.            %%%%%%%%
\title{INFO0947: \intitule}
\author{Groupe \GrNbr : \PrenomUN~\textsc{\NomUN}, \PrenomDEUX~\textsc{\NomDEUX}}
\date{\today}
\begin{document}
\maketitle
\newpage
\tablemat
\newpage
%%%%%%%%%%%%%%%%%%%% FIN DE LA ZONE PROTÉGÉE %%%%%%%%%%%%%%%%%%%%

\section{Spécifications des TAD}
	
	\subsection{Escale\_t}
		\begin{tabular}{|p{17cm}|c}
			\hline
			\\
			
			\textbf{Types:}
				\begin{itemize}
					\item[] Escale
				\end{itemize}
			
			\textbf{Utilise:}
				\begin{itemize}
					\item[] float
					\item[] String
				\end{itemize}
			
			\textbf{Opérations\footnotemark{}:}
				\begin{itemize}
					\item[] \textcolor{red}{create\_stopover}:\textcolor{green}{float} $\times$ \textcolor{green}{float} $\times$ \textcolor{green}{String} $\rightharpoonup$ \textcolor{blue}{Escale}
					\item[] \textcolor{red}{log\_time}: \textcolor{green}{Escale} $\times$ \textcolor{green}{float} $\rightharpoonup$ \textcolor{blue}{Escale}
					\item[] \textcolor{red}{free\_stopover}: \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{void}
					\item[] \textcolor{red}{calculate\_range}: \textcolor{green}{Escale} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{float}
					\item[] \textcolor{magenta}{get\_name}: \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{String}
					\item[] \textcolor{magenta}{get\_latitude}: \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{float}
					\item[] \textcolor{magenta}{get\_longitude}: \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{float}
					\item[] \textcolor{magenta}{get\_best\_time}: \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{float}
				\end{itemize}
			
			\textbf{Préconditions:}
				\begin{itemize}
					\item[$\bullet$] $\forall \hspace{1mm} x \in float, \hspace{1mm} x \in [-90,90] \hspace{2mm} \&\& \hspace{2mm} \forall \hspace{1mm} y \in float, \hspace{1mm} y \in [-180,180]  \hspace{2mm} \&\&$ \newline $\forall \hspace{1mm} name \neq \oslash \Rightarrow create\_stopover(x \hspace{1mm} , \hspace{1mm} y \hspace{1mm} , \hspace{1mm} *name)$
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \hspace{2mm} \&\& \hspace{2mm} \forall \hspace{1mm} time \geq 0 \Rightarrow log\_time(*x \hspace{1mm} , \hspace{1mm} time) $
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \Rightarrow free\_stopover(*x)$ 
					\item[$\bullet$] $\forall \hspace{1mm} x, \hspace{1mm} y \in Escale \neq \oslash \Rightarrow calculate\_range(*x \hspace{1mm} , \hspace{1mm} *y)$
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \Rightarrow get\_name(*x)$ 
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \Rightarrow get\_latitude(*x)$ 
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \Rightarrow get\_longitude(*x)$ 
					\item[$\bullet$] $\forall \hspace{1mm} x \in Escale \neq \oslash \Rightarrow get\_best\_time(*x)$ 
				\end{itemize}
				
			\textbf{Axiomes:}
				\begin{itemize}
					\item[$\bullet$] 
				\end{itemize}
				
			\\	
			\hline
		\end{tabular}
		 
		\footnotetext{\textcolor{red}{Nom des opérations interne}} 
		\footnotetext{\textcolor{green}{Arguments}} 
		\footnotetext{\textcolor{blue}{Types de retour}} 
		\footnotetext{\textcolor{magenta}{Nom des opérations d'observation}}
		
		
	\subsection{Course\_t} 
		\subsubsection{Tableau}
			\begin{tabular}{|p{17cm}|c}
				\hline
				\\
				
				\textbf{Types:}
					\begin{itemize}
						\item[] Course
					\end{itemize}
				
				\textbf{Utilise:}
					\begin{itemize}
						\item[] Escale
						\item[] float
						\item[] unsigned int
					\end{itemize}
				
				\textbf{Opérations\footnotemark{}:}
					\begin{itemize}
						\item[] \textcolor{red}{memory\_allocation}:\textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{right\_shift}: \textcolor{green}{Course} $\times$ \textcolor{green}{unsigned int} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{left\_shift}: \textcolor{green}{Course} $\times$ \textcolor{green}{unsigned int} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{create\_table\_race}: \textcolor{green}{Escale} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{add\_table\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\times$ \textcolor{green}{int} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{remove\_table\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{int} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{obtain\_table\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{int} $\rightharpoonup$ \textcolor{blue}{Escale}
						\item[] \textcolor{red}{free\_table\_race}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{void}
						\item[] \textcolor{red}{is\_table\_circuit}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{unsigned int}
						\item[] \textcolor{red}{race\_table\_time}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{float}
						\item[] \textcolor{magenta}{get\_table\_stopover}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{unsigned int}
						\item[] \textcolor{magenta}{get\_step}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{unsigned int}
						\item[] \textcolor{magenta}{get\_time}: \textcolor{green}{Course} $\times$ \textcolor{green}{int} $\rightharpoonup$ \textcolor{blue}{float}
					\end{itemize}
				
				\textbf{Préconditions:}
					\begin{itemize}
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course, \hspace{1mm}  \Rightarrow memory\_allocation(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course, \hspace{1mm}  \Rightarrow right\_shift(*x\hspace{1mm} , \hspace{1mm} start)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course, \hspace{1mm}  \Rightarrow left\_shift(*x\hspace{1mm} , \hspace{1mm} start)$
						\item[$\bullet$] $\forall \hspace{1mm} x, \hspace{1mm} y \in Escale \neq \oslash \Rightarrow create\_table\_race(*x \hspace{1mm} , \hspace{1mm} *y)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm}, \hspace{1mm} y \in Escale \hspace{1mm}, \hspace{1mm} x \hspace{1mm},\hspace{1mm}y \neq \oslash \Rightarrow add\_table\_stopover(*x \hspace{1mm} , \hspace{1mm} *y \hspace{1mm} , \hspace{1mm} position)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow remove\_table\_stopover(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow obtain\_table\_stopover(*x \hspace{1mm} , \hspace{1mm} position)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow free\_table\_race(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow is\_table\_circuit(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow race\_table\_time(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow get\_table\_stopover(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash \Rightarrow get\_step(*x)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm} , \hspace{1mm} x \neq \oslash  \hspace{1mm} \&\& \hspace{1mm} \forall \hspace{1mm} y \in int \hspace{1mm} , \hspace{1mm} y \hspace{1mm} < \hspace{1mm} nbrStopover \Rightarrow get_time(*x, y)$
					\end{itemize}
					
				\textbf{Axiomes:}
					\begin{itemize}
						\item[$\bullet$]
					\end{itemize}
					
				\\	
				\hline
			\end{tabular}
		
		\footnotetext{\textcolor{red}{Nom des opérations interne}} 
		\footnotetext{\textcolor{green}{Arguments}} 
		\footnotetext{\textcolor{blue}{Types de retour}} 
		\footnotetext{\textcolor{magenta}{Nom des opérations d'observation}}
		
		\subsubsection{Liste chaînée}
			\begin{tabular}{|p{17cm}|c}
				\hline
				\\
				
				\textbf{Types:}
					\begin{itemize}
						\item[] Cell
					\end{itemize}
				
				\textbf{Utilise:}
					\begin{itemize}
						\item[] Escale
						\item[] Cell
						\item[] unsigned int
					\end{itemize}
				
				\textbf{Opérations\footnotemark{}:}
					\begin{itemize}
						\item[] \textcolor{red}{create\_liste\_race}: \textcolor{green}{Escale} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{Course}
						\item[] \textcolor{red}{obtain\_list\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{Escale}
						\item[] \textcolor{red}{add\_start}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{void*}
						\item[] \textcolor{red}{add\_end}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{void*}
						\item[] \textcolor{red}{remove\_list\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{void}
						\item[] \textcolor{red}{print\_race}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{void}
						\item[] \textcolor{red}{free\_list\_race}: \textcolor{green}{Course} $\rightharpoonup$ \textcolor{blue}{void}
						\item[] \textcolor{red}{add\_list\_stopover}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\times$ \textcolor{green}{int} $\rightharpoonup$ \textcolor{blue}{void*}
						\item[] \textcolor{red}{stopover\_race\_time}: \textcolor{green}{Course} $\times$ \textcolor{green}{Escale} $\rightharpoonup$ \textcolor{blue}{float}
						\item[] \textcolor{red}{race\_list\_time}: \textcolor{green}{Course}$\rightharpoonup$ \textcolor{blue}{float}
						\item[] \textcolor{red}{is\_list\_circuit}: \textcolor{green}{Course}$\rightharpoonup$ \textcolor{blue}{unsigned int}
						\item[] \textcolor{magenta}{get\_list\_stopover}: \textcolor{green}{Course}$\rightharpoonup$ \textcolor{blue}{unsigned int}
					\end{itemize}
				
				\textbf{Préconditions:}
					\begin{itemize}
						\item[$\bullet$] $\forall \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash \Rightarrow create\_list\_race(*x \hspace{1mm} , \hspace{1mm}*y)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  obtain\_list\_stopover(*x \hspace{1mm} , \hspace{1mm }*y)$
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  add\_start(**x \hspace{1mm} , \hspace{1mm} *y)$						
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  add\_end(**x \hspace{1mm} , \hspace{1mm} *y)$						
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  remove\_list\_stopover(**x \hspace{1mm} ,\hspace{1mm} *y)$	
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course,\hspace{1mm} x \neq \oslash \Rightarrow  print_race(*x)$	
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course,\hspace{1mm} x \neq \oslash \Rightarrow  free\_list\_race(*x)$	
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  add\_list\_stopover(**x \hspace{1mm} , \hspace{1mm} *y \hspace{1mm} , \hspace{1mm} position)$			
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course \hspace{1mm},\hspace{1mm} \forall y \in Escale, \hspace{1mm} x \hspace{1mm} , \hspace{1mm} y  \neq \oslash  \Rightarrow  stopover\_race\_time(*x \hspace{1mm} , \hspace{1mm} *y)$			
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course,\hspace{1mm} x \neq \oslash \Rightarrow  race\_list\_time(*x)$	
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course,\hspace{1mm} x \neq \oslash \Rightarrow  is\_list\_circuit(*x)$	
						\item[$\bullet$] $\forall \hspace{1mm} x \in Course,\hspace{1mm} x \neq \oslash \Rightarrow  get\_list\_stopover(*x)$	
					\end{itemize}
					
				\textbf{Axiomes:}
					\begin{itemize}
						\item[$\bullet$]
					\end{itemize}
					
				\\	
				\hline
			\end{tabular}
		
		\footnotetext{\textcolor{red}{Nom des opérations interne}} 
		\footnotetext{\textcolor{green}{Arguments}} 
		\footnotetext{\textcolor{blue}{Types de retour}} 
		\footnotetext{\textcolor{magenta}{Nom des opérations d'observation}}
		
	\newpage
	
\section{Déscriptions des TAD}

	\subsection{Escale}
	
	Cette structure permettra d'implémenté le TAD Escale permettant de créer une escale avec les position géographique de chaque étapes,
	et de stocker chaque étapes avec un nom.
	L'escale comportera le meilleur temps pour la parcourir.
	
		\begin{lstlisting}
struct Escale_t {
	float s_latitude;
	float s_longitude;
	float s_bestTime;
	char *s_name;
};
		\end{lstlisting}
		
		\begin{itemize}
			\item[$\bullet$] float $s\_latitude;$
			\begin{itemize}
				\item[] Permet de stocker la latitude d'une étape.
			\end{itemize}
			\item[$\bullet$] float $s\_longitude;$
			\begin{itemize}
				\item[] Permet de stocker la longitude d'une étape.
			\end{itemize}
			\item[$\bullet$] float $s\_bestTime;$
			\begin{itemize}
				\item[] Permet de stocker le meilleur temps de l'escale.
			\end{itemize}
			\item[$\bullet$] char $*s\_name;$
			\begin{itemize}
				\item[] Permet de stocker le nom de chaque étapes.
			\end{itemize}
		\end{itemize}
		
	\subsection{Course}
	
		Cette structure permettra d'implémenté le TAD Course basée sur un tableau.
	Cette structure comprendra un pointeur sur le TAD escale permettant d'obtenir ses variables.
	Une taille du tableau qui dépendra du nombre d'escale.
	Ces variables me permettrons de trouvé le meilleur temps d'une course.
		
		\begin{lstlisting}
struct Course_t {
	Escale **s_stopover;
	float s_bestTime;
	unsigned int s_sizeBoard;
	unsigned int s_nbrStopover;
};
		\end{lstlisting}
		
		\begin{itemize}
			\item[$\bullet$] Escale $**s\_stopover;$
			\begin{itemize}
				\item[] Un pointeur sur le TAD Escale.
			\end{itemize}
			\item[$\bullet$] float $s\_bestTime;$
			\begin{itemize}
				\item[] Permet de stocker le meilleur temps de la course.
			\end{itemize}
			\item[$\bullet$] unsigned int $s\_sizeBoard;$
			\begin{itemize}
				\item[] Permet de stocker la taille du tableau.
			\end{itemize}
			\item[$\bullet$] unsigned int $s\_nbrStopover;$
			\begin{itemize}
				\item[] Permet de stocker le nombre d'escale présente dans la course.
			\end{itemize}
		\end{itemize}
		
	\newpage
		
	\subsection{Cell}
	
			Cette structure permettra d'implémenté le TAD Course basée sur un tableau. 
		Cette structure comprendra un pointeur sur le TAD escale permettant d'obtenir ses variables.
		Elle contient aussi un pointeur sur la structure Cell.
		Une variable permettra de trouver le nombre d'escale.	
	
		\begin{lstlisting}
typedef Course Cell;

struct Course_t {
	Escale *s_stopover;
	Cell *s_next_stopover;
	unsigned int s_nbrStopover;
};
		\end{lstlisting}
		
		\begin{itemize}
			\item[$\bullet$] Escale $*s\_stopover;$
			\begin{itemize}
				\item[] Un pointeur sur le TAD Escale.
			\end{itemize}
			\item[$\bullet$] Cell $*s\_next\_stopover;$
			\begin{itemize}
				\item[] Un pointeur sur une cellule de la liste.
			\end{itemize}
			\item[$\bullet$] unsigned int $s\_nbrStopover;$
			\begin{itemize}
				\item[] Permet de stocker le nombre d'escale dans la course.
			\end{itemize}
		\end{itemize}
		
\section{Avantages et inconvénients}

	\subsection{Escale}
	
		\begin{itemize}
			\item[] Avantages
			\begin{itemize}
				\item[]
			\end{itemize}
			\item[] Inconvénients
			\begin{itemize}
				\item[] 
			\end{itemize}
		\end{itemize}
		
\section{Sous-problèmes}

	\begin{itemize}
		\item[] $SP_1$ :
		\begin{itemize}
			\item[-] Créé le TAD Escale permettant de créé une escale et enregistrer un meilleur temps.
		\end{itemize}
		\item[] $SP_2$ :
		\begin{itemize}
			\item[-] Créé le TAD course sous forme de tableau.
		\end{itemize}
		\item[] $SP_3$ :
		\begin{itemize}
			\item[-] Créé les tests pour le TAD sous forme de tableau.
		\end{itemize}
		\item[] $SP_4$ :
		\begin{itemize}
			\item[-] Créé le TAD course sous forme de Liste.
		\end{itemize}
		\item[] $SP_5$ :
		\begin{itemize}
			\item[-] Créé les tests pour le TAD sous forme de liste.
		\end{itemize}
	\end{itemize}
	
	\vspace{5mm}
	
	\begin{itemize}
		\item[] $SP_1 \subset SP_2 \subset SP_4 \rightarrow SP_5$
		\item[] $SP_2 \rightarrow SP_3$
	\end{itemize}
	
\newpage

\section{Spécification de fonctions}

	\subsection{course\_liste.c}
	
% create_list_race %
		\begin{lstlisting}
/**
 * @fn Course create_list_race*(Escale*, Escale*)
 * @brief Allows you to initialize the race structure
 *
 * @pre p_stopover != NULL && p_secondStopover != NULL
 * @post a race was create with connection cell
 * @param p_stopover the first stopover
 * @param p_secondStopover the second stopover
 * @return Course * a memory allowed pointer to the header of the course structure
 * 			NULL on error
 */
Course* create_list_race(Escale *p_stopover, Escale *p_secondStopover);
		\end{lstlisting}

% obtain_list_stopover %
		\begin{lstlisting}
/**
 * @fn Escale obtain_list_stopover*(Course*, Escale*)
 * @brief getter of the data of a cell
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 * @return Escale *a pointer to the data Escale structure
 * 			NULL on error
 */
Escale* obtain_list_stopover(Course *p_race, Escale *p_stopover);
		\end{lstlisting}

% add_start %
		\begin{lstlisting}
/**
 * @fn void add_start*(Course**, Escale*)
 * @brief Allows you to add a stopover at the start
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post p_stopover0 < p_stopover
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 */
void* add_start(Course **p_race, Escale *p_stopover);
		\end{lstlisting}
		
% add_end %
		\begin{lstlisting}
/**
 * @fn void add_end*(Course**, Escale*)
 * @brief Allows you to add a stopover at the end
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post p_stopover0 < p_stopover
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 */
void* add_end(Course **p_race, Escale *p_stopover);
		\end{lstlisting}

% remove_list_stopover %
		\begin{lstlisting}
/**
 * @fn void remove_list_stopover(Course**, Escale*)
 * @brief Allows you to remove a stopover to the structure
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post a stopover has been removed
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 */
void remove_list_stopover(Course **p_race, Escale *p_stopover);
		\end{lstlisting}
		
% print_race %
		\begin{lstlisting}
/**
 * @fn void print_race(Course*)
 * @brief Allows you to display the race in the console
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 */
void print_race(Course *p_race);
		\end{lstlisting}
		
% free_list_race %
		\begin{lstlisting}
/**
 * @fn void free_list_race(Course*)
 * @brief Used to free the memory of the Course structure
 *
 * @pre p_race != NULL
 * @post Course *p_race is released
 * @param p_race a pointer to the Course structure
 */
void free_list_race(Course *p_race);
		\end{lstlisting}

% add_list_stopover %		
		\begin{lstlisting}
/**
 * @fn void add_list_stopover*(Course**, Escale*, int)
 * @brief Allows you to add a stopover to the structure
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post a stopover has been added
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 * @param p_position the position in the list
 */
void *add_list_stopover(Course **p_race, Escale *p_stopover, int p_position);
		\end{lstlisting}
	
% stopover_race_time %			
		\begin{lstlisting}
/**
 * @fn float stopover_race_time(Course*, Escale*)
 * @brief allows you to find the best time of the stage
 *
 * @pre p_race != NULL && p_stopover != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @param p_stopover  pointer to the Escale structure
 * @return float l_time
 * 			NULL on error
 */
float stopover_race_time(Course *p_race, Escale *p_stopover);
		\end{lstlisting}
		
\newpage
% race_list_time %			
		\begin{lstlisting}
/**
 * @fn float race_table_time(Course*)
 * @brief get time to race
 *
 * @pre p_race != NULL
 * @post p_race->s_bestTime0 != p_race->s_bestTime
 * @param p_race a pointer to the Course structure
 * @return float p_race->s_bestTime
 */
float race_list_time(Course *p_race);
		\end{lstlisting}
		
% is_list_circuit %					
		\begin{lstlisting}
/**
 * @fn unsigned int is_list_circuit(Course*)
 * @brief Used to determine if the race is a circuit
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @return 0 if the race is not a circuit
 * 			1 else
 */
unsigned int is_list_circuit(Course *p_race);
		\end{lstlisting}
		
% get_list_stopover %			
		\begin{lstlisting}
/**
 * @fn unsigned int get_list_stopover(Course*)
 * @brief getter of the number of stopover
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @return unsigned int p_race->s_nbrStopover
 */
unsigned int get_list_stopover(Course *p_race);
		\end{lstlisting}
		
	\newpage
	
	\subsection{course\_tableau.c}
	
% memory_allocation %			
		\begin{lstlisting}
/**
 * @fn Course memory_allocation*(Course*)
 * @brief Allows memory to be reallocated for a race
 *
 * @pre p_race != NULL
 * @post p_race memory0 < p_race memory
 * @param p_race a pointer to the Course structure
 * @return Course * a pointer to the header of the course structure
 */
static Course* memory_allocation(Course *p_race);
		\end{lstlisting}
		
% right_shift %			
		\begin{lstlisting}
/**
 * @fn Course right_shift*(Course*, unsigned int)
 * @brief Allows you to shift a box in the table to the right
 *
 * @pre p_race != NULL
 * @post p_race->s_sizeBoard < p_race->s_nbrStopover
 * @param p_race a pointer to the Course structure
 * @param p_start the nth cell of the table to shift
 * @return Course * a pointer to the header of the course structure
 */
static Course* right_shift(Course *p_race, unsigned int p_start);
		\end{lstlisting}
		
% left_shift %			
		\begin{lstlisting}
/**
 * @fn Course left_shift*(Course*, unsigned int)
 * @brief Allows you to shift a box in the table to the left
 * 
 * @pre p_race != NULL
 * @post p_race->s_sizeBoard < p_race->s_nbrStopover
 * @param p_race a pointer to the Course structure
 * @param p_start the nth cell of the table to shift
 * @return Course * a pointer to the header of the course structure
 */
static Course* left_shift(Course *p_race, unsigned int p_start);
		\end{lstlisting}
		
%  create_table_race %			
		\begin{lstlisting}
/**
 * @fn Course create_table_race*(Escale*, Escale*)
 * @brief Allows you to initialize the race structure
 *
 * @pre p_stopover != NULL && p_secondStopover != NULL
 * @post a race was create with connection cell
 * @param p_stopover the first stopover
 * @param p_secondStopover the second stopover
 * @return Course * a memory allowed pointer to the header of the course structure
 * 			NULL on error
 */
Course* create_table_race(Escale *p_stopover, Escale *p_secondStopover);
		\end{lstlisting}
		
\newpage 

% add_table_stopover %			
		\begin{lstlisting}
/**
 * @fn Course add_table_stopover*(Course*, Escale*, int)
 * @brief Allows you to add a stopover to the structure
 *
 * @pre p_race != NULL && p_stopover != NULL && p_position > 0
 * @post a stopover has been added
 * @param p_race a pointer to the Course structure
 * @param p_stopover a pointer to the Escale structure
 * @param p_position the position in the list
 * @return Course * a pointer to the header of the course structure
 * 			NULL on error
 */
Course* add_table_stopover(Course *p_race, Escale *p_stopover, int p_position);
		\end{lstlisting}
		
% remove_table_stopover %			
		\begin{lstlisting}
/**
 * @fn Course remove_table_stopover*(Course*, int)
 * @brief Allows you to remove a stopover to the structure
 *
 * @pre p_race != NULL && p_position > 0
 * @post a stopover has been removed
 * @param p_race a pointer to the Course structure
 * @param p_position the position in the list
 * @return Course * a pointer to the header of the course structure
 * 			NULL on error
 */
Course* remove_table_stopover(Course *p_race, int p_position);
		\end{lstlisting}
		
% obtain_table_stopover %			
		\begin{lstlisting}
/**
 * @fn Escale obtain_table_stopover*(Course*, int)
 * @brief getter of the data of a cell
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @param p_position the position in the list
 * @return Escale *a pointer to the data Escale structure
 * 			NULL on error
 */
Escale* obtain_table_stopover(Course *p_race, int p_position);
		\end{lstlisting}
		
% free_table_race %			
		\begin{lstlisting}
/**
 * @fn void free_table_race(Course*)
 * @brief Used to free the memory of the Course structure
 *
 * @pre p_race != NULL
 * @post Course *p_race is released
 * @param p_race a pointer to the Course structure
 */
void free_table_race(Course *p_race);
		\end{lstlisting}

\newpage 
		
% is_table_circuit %			
		\begin{lstlisting}
/**
 * @fn unsigned int is_table_circuit(Course*)
 * @brief Used to determine if the race is a circuit
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @return 0 if the race is not a circuit
 * 			1 else
 */
unsigned int is_table_circuit(Course *p_race);
		\end{lstlisting}
		
% race_table_time %			
		\begin{lstlisting}
/**
 * @fn float race_table_time(Course*)
 * @brief get time to race
 *
 * @pre p_race != NULL
 * @post p_race->s_bestTime0 != p_race->s_bestTime
 * @param p_race a pointer to the Course structure
 * @return float p_race->s_bestTime
 */
float race_table_time(Course *p_race);
		\end{lstlisting}
		
% get_table_stopover %			
		\begin{lstlisting}
/**
 * @fn unsigned int get_table_stopover(Course*)
 * @brief getter of the number of stopover
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @return unsigned int p_race->s_nbrStopover
 */
unsigned int get_table_stopover(Course *p_race);
		\end{lstlisting}
		
% get_step %			
		\begin{lstlisting}
/**
 * @fn unsigned int get_step(Course*)
 * @brief getter of the number of step
 *
 * @pre p_race != NULL
 * @post /
 * @param p_race a pointer to the Course structure
 * @return unsigned int p_race->s_nbrStopover -1
 */
unsigned int get_step(Course *p_race);
		\end{lstlisting}
		
% get_time %			
		\begin{lstlisting}
/**
 * @fn float get_time(Course*, int)
 * @brief
 *
 * @pre p_race != NULL && p_position < p_race->s_nbrStopover
 * @post /
 * @param p_race a pointer to the Course structure
 * @param p_position the position in the list
 * @return float l_time
 */
float get_time(Course *p_race, int p_position);
		\end{lstlisting}
		
% Section documentation
\section{Documentation}	
	Pour plus d'informations sur le code vous pouvez consulter le \href{doc/html/index.html}{site internet} contenant la documentation doxygen.
\end{document}
		
\end{document}